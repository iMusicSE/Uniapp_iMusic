<template>
	<view class="player-page" :style="{ background: bgColor }">
		<!-- 顶部栏 -->
		<view class="top-bar">
			<text class="back-icon" @click="goBack">＜</text>
			<view class="song-title">
				<text class="title">{{ displayTitle }}</text>
				<text class="subtitle">{{ displaySubtitle }}</text>
			</view>
			<text v-if="!isRadioMode" class="share-icon" @click="share">⋯</text>
		</view>
		
	<!-- 电台模式 - 显示电台动画 -->
	<view v-if="isRadioMode" class="radio-section">
		<view class="radio-container">
			<view class="radio-waves" :class="{ 'active': isPlaying }">
				<view class="wave"></view>
				<view class="wave"></view>
				<view class="wave"></view>
			</view>
			<view class="radio-icon-large">📻</view>
		</view>
		<view class="radio-info">
			<text class="radio-status">{{ isPlaying ? '🔴 正在播放' : '⏸ 已暂停' }}</text>
			<text class="radio-meta">{{ currentRadio?.country || '' }} · {{ currentRadio?.bitrate || '' }}kbps</text>
		</view>
	</view>
	
	<!-- 音乐模式 - 封面区域 -->
	<view v-else-if="!showLyrics" class="cover-section" @click="toggleLyrics">
		<view class="cover-container" :class="{ 'rotating': isPlaying }">
			<image 
				class="cover-image" 
				:src="currentSong ? currentSong.albumPic : '/static/logo.png'" 
				mode="aspectFill"
			></image>
			<view class="cover-disc"></view>
		</view>
	</view>
	
	<!-- 音乐模式 - 歌词区域 -->
	<view v-else-if="showLyrics" class="lyrics-section" @click="toggleLyrics">
		<scroll-view 
			id="lyrics-scroll-view"
			class="lyrics-scroll" 
			scroll-y 
			:scroll-top="lyricsScrollTop"
			:scroll-with-animation="true"
		>
			<view class="lyrics-list">
				<!-- 顶部填充空间，使第一句歌词可以居中 -->
				<view class="lyrics-padding"></view>
				<view 
					:id="'lyric-line-' + index"
					class="lyric-line" 
					v-for="(line, index) in lyrics" 
					:key="index"
					:class="{ 'active': currentLyricIndex === index }"
				>
					{{ line.text }}
				</view>
				<view class="lyrics-end">- END -</view>
				<!-- 底部填充空间，使最后一句歌词可以居中 -->
				<view class="lyrics-padding"></view>
			</view>
		</scroll-view>
	</view>
		
	<!-- 操作栏 (仅音乐模式) -->
	<view v-if="!isRadioMode" class="action-bar">
		<text class="action-icon" :class="{ 'active': isFavorite(currentSong?.id) }" @click="toggleFavorite(currentSong)">
			{{ isFavorite(currentSong?.id) ? '❤️' : '🤍' }}
		</text>
		<text class="action-icon" @click="downloadSong">⬇️</text>
		<text class="action-icon" @click="comment">💬</text>
		<text class="action-icon" @click="showMusicInfo">🛈</text>
	</view>
		
		<!-- 进度条 (仅音乐模式) -->
		<view v-if="!isRadioMode" class="progress-section">
			<text class="time-text">{{ formatTime(currentTime) }}</text>
			<slider 
				class="progress-slider" 
				:value="currentTime" 
				:max="duration || 100" 
				:block-size="12"
				activeColor="#fff"
				backgroundColor="rgba(255, 255, 255, 0.3)"
				@changing="onSliderChanging"
				@change="onSliderChange"
			/>
			<text class="time-text">{{ formatTime(duration) }}</text>
		</view>
		
		<!-- 控制栏 -->
		<view class="control-section" :class="{ 'radio-controls': isRadioMode }">
			<!-- 音乐模式控制 -->
			<template v-if="!isRadioMode">
				<view class="control-btn" @click="togglePlayMode">
					<text class="control-icon">{{ playModeIcon }}</text>
				</view>
				<view class="control-btn" @click="playPrevious">
					<text class="control-icon large">⏮</text>
				</view>
				<view class="control-btn play-btn" @click="togglePlay">
					<text class="control-icon extra-large">{{ isPlaying ? '⏸' : '▶' }}</text>
				</view>
				<view class="control-btn" @click="playNext">
					<text class="control-icon large">⏭</text>
				</view>
				<view class="control-btn" @click="showPlaylist">
					<text class="control-icon">☰</text>
				</view>
			</template>
			
			<!-- 电台模式控制 -->
			<template v-else>
				<view class="control-btn play-btn" @click="togglePlay">
					<text class="control-icon extra-large">{{ isPlaying ? '⏸' : '▶' }}</text>
				</view>
				<view class="control-btn" @click="stopRadioAndBack">
					<text class="control-icon large">⏹</text>
				</view>
			</template>
		</view>
		
		<!-- 播放列表弹窗 -->
		<Playlist :visible="playlistVisible" @close="playlistVisible = false" />
	</view>
</template>

<script>
import { mapState, mapGetters, mapActions } from 'vuex'
import Playlist from '@/components/Playlist.vue'
import { getLyrics } from '@/utils/api.js'



export default {
	components: {
		Playlist
	},
	data() {
		return {
			bgColor: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
			lyrics: [],
			currentLyricIndex: 0,
			lyricsScrollTop: 0,
			showLyrics: false,
			loadingLyrics: false,
			playlistVisible: false
		}
	},
	computed: {
		...mapState('user', {
		      userInfo: state => state  // user 模块的整个 state 映射为 this.userInfo
		    }),
		...mapState('player', [
			'currentSong', 
			'isPlaying', 
			'currentTime', 
			'duration', 
			'playMode', 
			'audioContext',
			'isRadioMode',
			'currentRadio'
		]),
		...mapGetters('favorites', ['isFavorite']),
		
		displayTitle() {
			if (this.isRadioMode && this.currentRadio) {
				return this.currentRadio.name
			}
			return this.currentSong ? this.currentSong.name : '暂无播放'
		},
		
		displaySubtitle() {
			if (this.isRadioMode && this.currentRadio) {
				return '在线电台'
			}
			return this.currentSong ? this.currentSong.artistName : ''
		},
		
		playModeIcon() {
			const icons = ['🔁', '🔂', '🔀']
			return icons[this.playMode]
		}
	},
	watch: {
		currentSong(newSong) {
			if (newSong) {
				this.loadLyrics(newSong.id)
			}
		},
		currentTime() {
			this.updateCurrentLyric()
		}
	},
	async onLoad(options) {
	  // 电台模式
	  if (options.radioMode) {
	    // 电台模式，不需要加载歌曲数据
	    return
	  }
	  
	  if (options.song) {
	    try {
	      const song = JSON.parse(decodeURIComponent(options.song));
	      
	      // 检查是否是同一首歌
	      const isSameSong = this.currentSong && this.currentSong.id === song.id;
	      
	      // 只有在切换歌曲时才更新currentSong
	      if (!isSameSong) {
	        this.$store.commit('player/SET_CURRENT_SONG', song);
	      }
	      
	      console.log('歌词路径:', song.lyricsPath);

	      // 只有在没有audioContext或切换歌曲时才重新初始化音频
	      if (!isSameSong && (song.localPath || song.url)) {
	        this.initAudio(song.localPath || song.url);
	      }

	      // 优先加载本地歌词
	      if (song.lyricsPath) {
	        try {
	          const res = await fetch(song.lyricsPath);
	          const text = await res.text();
	          if (text && text.length > 0) {
	            this.parseLyrics(text);
	            console.log("✅ 已加载本地歌词");
	            return;
	          }
	        } catch (err) {
	          console.warn("⚠️ 本地歌词读取失败，尝试网络歌词");
	        }
	      }

	      // 如果没有本地歌词或失败，则走网络歌词
	      await this.loadLyrics(song.id || song.songId);

	    } catch (err) {
	      console.error("解析歌曲数据失败:", err);
	    }
		  
	  } else if(this.currentSong) {
	    // 从 store 加载歌曲时，也需要初始化 audio（如果还没有的话）
	    console.log('从 store 加载歌曲:', this.currentSong);
	    if (!this.audioContext && this.currentSong.url) {
	      this.initAudio(this.currentSong.url);
	    }
	    
	    // 加载歌词
	    if (this.currentSong.lyricsPath) {
	      try {
	        const res = await fetch(this.currentSong.lyricsPath);
	        const text = await res.text();
	        if (text && text.length > 0) {
	          this.parseLyrics(text);
	          console.log("✅ 已加载本地歌词");
	          return;
	        }
	      } catch (err) {
	        console.warn("⚠️ 本地歌词读取失败，尝试网络歌词");
	      }
	    }
		  this.loadLyrics(this.currentSong.id);
	  }

	  // 音频时间同步
	  if (this.audioContext) {
	    this.audioContext.onTimeUpdate(() => {
	      this.$store.commit("player/SET_CURRENT_TIME", this.audioContext.currentTime);
	      this.$store.commit("player/SET_DURATION", this.audioContext.duration);
	    });
	  }
	},
	methods: {
		initAudio(url) {
		    // 如果已经有 audioContext，先停止
		    if (this.audioContext) {
		      this.audioContext.pause();
		      this.$store.commit('player/SET_AUDIO_CONTEXT', null);
		    }
		
		    // uniapp 创建 audioContext
		    const audioCtx = uni.createInnerAudioContext();
		    audioCtx.src = url;        // 本地文件路径或网络路径
		    audioCtx.autoplay = true;  // 自动播放
		    audioCtx.loop = false;
		
	    // 监听播放状态
	    audioCtx.onPlay(() => {
	      this.$store.commit('player/SET_PLAY_STATE', true);
	    });
	
	    audioCtx.onPause(() => {
	      this.$store.commit('player/SET_PLAY_STATE', false);
	    });
	
	    audioCtx.onEnded(() => {
	      this.$store.commit('player/SET_PLAY_STATE', false);
	      this.playNext();  // 播放下一首
	    });
		
		    audioCtx.onTimeUpdate(() => {
		      this.$store.commit('player/SET_CURRENT_TIME', audioCtx.currentTime);
		      this.$store.commit('player/SET_DURATION', audioCtx.duration);
		    });
		    
		    // 通过 mutation 设置 audioContext
		    this.$store.commit('player/SET_AUDIO_CONTEXT', audioCtx);
		  },
		
		...mapActions({
			togglePlay: 'player/togglePlay',
			playNext: 'player/playNext',
			playPrevious: 'player/playPrevious',
			togglePlayMode: 'player/togglePlayMode',
			toggleFavorite: 'favorites/toggleFavorite',
			stopRadio: 'player/stopRadio'
		}),
		
		stopRadioAndBack() {
			this.stopRadio()
			uni.navigateBack()
		},
		
		goBack() {
			uni.navigateBack()
		},
		
		share() {
			uni.showActionSheet({
				itemList: ['分享到微信', '分享到QQ', '复制链接'],
				success: (res) => {
					uni.showToast({
						title: '分享功能待开发',
						icon: 'none'
					})
				}
			})
		},
		
		
		async downloadSong() {
		  if (!this.currentSong || !this.currentSong.url) {
		    return uni.showToast({ title: '暂无可下载的歌曲', icon: 'none' });
		  }
		
		  const userId = this.userInfo.userId;
		  if (!userId) {
		    return uni.showToast({ title: '请先登录后下载', icon: 'none' });
		  }
		
		  const song = this.currentSong;
		  uni.showLoading({ title: '正在下载...' });
		
		  try {
		    // ✅ 获取歌词文本
		    let lyricsText = '';
		    try {
		      const lyricsRes = await getLyrics(song.id);
		      if (lyricsRes.data?.lrc?.lyric) {
		        lyricsText = lyricsRes.data.lrc.lyric;
		      }
		    } catch (e) {
		      console.warn('获取歌词失败:', e);
		    }
		
		    // 调用下载接口
		    const res = await uni.request({
		      url: 'http://localhost:3000/downloads/add', // 你的下载接口
		      method: 'POST',
		      data: {
		        userId,
		        musicId: song.id,
		        songName: song.name,
		        artist: song.artistName || '未知歌手',
		        album: song.albumName || '未知专辑',
		        coverUrl: song.albumPic || '',
		        fileUrl: song.url,        // 歌曲 mp3
		        lyricsText                // ✅ 传歌词文本给后端
		      }
		    });
		
		    console.log('接口返回:', res);
		
		    if (res.data.success) {
		      uni.showToast({ title: '下载成功', icon: 'success' });
		      console.log('✅ 音乐路径:', res.data.musicPath);
		      console.log('✅ 歌词路径:', res.data.lyricsPath);
		    } else {
		      uni.showToast({ title: '下载失败', icon: 'none' });
		      console.warn('❌ 下载失败：', res.data.message);
		    }
		
		  } catch (err) {
		    console.error('❌ 下载出错：', err);
		    uni.showToast({ title: '下载出错', icon: 'none' });
		  } finally {
		    uni.hideLoading();
		  }
		},


		
	comment() {
		uni.showToast({
			title: '评论功能待开发',
			icon: 'none'
		})
	},
	
	showMusicInfo() {
		uni.showToast({
			title: '正在开发中',
			icon: 'none'
		})
	},
	
	toggleLyrics() {
		this.showLyrics = !this.showLyrics
	},
	
	showPlaylist() {
		this.playlistVisible = true
	},
		
		// 加载歌词
		async loadLyrics(songId) {
					this.loadingLyrics = true
					this.lyrics = []
					this.currentLyricIndex = 0
					
					try {
						const res = await getLyrics(songId)
						
						if (res.statusCode === 200 && res.data && res.data.lrc && res.data.lrc.lyric) {
							this.parseLyrics(res.data.lrc.lyric)
						}
					} catch (error) {
						console.error('加载歌词错误:', error)
					} finally {
						this.loadingLyrics = false
					}
				},
		
		// 解析歌词
		parseLyrics(lrcText) {
			const lines = lrcText.split('\n')
			const lyricsArray = []
			
			const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g
			
			lines.forEach(line => {
				const matches = [...line.matchAll(timeRegex)]
				if (matches.length > 0) {
					const text = line.replace(timeRegex, '').trim()
					if (text) {
						matches.forEach(match => {
							const minutes = parseInt(match[1])
							const seconds = parseInt(match[2])
							const milliseconds = parseInt(match[3])
							const time = minutes * 60 + seconds + milliseconds / (match[3].length === 2 ? 100 : 1000)
							
							lyricsArray.push({
								time: time,
								text: text
							})
						})
					}
				}
			})
			
			lyricsArray.sort((a, b) => a.time - b.time)
			this.lyrics = lyricsArray
		},
		
		// 更新当前歌词
		updateCurrentLyric() {
			if (this.lyrics.length === 0) return
			
			let newLyricIndex = 0
			for (let i = 0; i < this.lyrics.length; i++) {
				if (this.currentTime < this.lyrics[i].time) {
					newLyricIndex = i - 1
					break
				}
				if (i === this.lyrics.length - 1) {
					newLyricIndex = i
				}
			}
			
			// 如果歌词索引发生变化，才滚动
			if (newLyricIndex >= 0 && newLyricIndex !== this.currentLyricIndex) {
				this.currentLyricIndex = newLyricIndex
				this.scrollToCenter()
			}
		},
		
		// 滚动到居中位置
		scrollToCenter() {
			this.$nextTick(() => {
				const query = uni.createSelectorQuery().in(this)
				
				// 获取滚动容器的高度
				query.select('#lyrics-scroll-view').boundingClientRect()
				// 获取当前激活歌词行的位置
				query.select('#lyric-line-' + this.currentLyricIndex).boundingClientRect()
				
				query.exec((res) => {
					if (res && res[0] && res[1]) {
						const scrollViewHeight = res[0].height
						const lyricLineTop = res[1].top
						const lyricLineHeight = res[1].height
						const scrollViewTop = res[0].top
						
						// 计算歌词行相对于滚动容器的位置
						const relativeTop = lyricLineTop - scrollViewTop
						
						// 计算需要滚动的距离，使歌词行位于容器中心
						// 目标位置 = 当前滚动位置 + 歌词行相对位置 - (容器高度 / 2) + (歌词行高度 / 2)
						const targetScrollTop = this.lyricsScrollTop + relativeTop - (scrollViewHeight / 2) + (lyricLineHeight / 2)
						
						// 更新滚动位置，确保不小于0
						this.lyricsScrollTop = Math.max(0, targetScrollTop)
					}
				})
			})
		},
		
		// 进度条拖动中
		onSliderChanging(e) {
			this.$store.commit('player/SET_CURRENT_TIME', e.detail.value)
		},
		
		// 进度条拖动结束
		onSliderChange(e) {
			if (this.audioContext) {
				this.audioContext.seek(e.detail.value)
			}
		},
		
		// 格式化时间
		formatTime(seconds) {
			if (isNaN(seconds) || seconds === 0) return '00:00'
			const mins = Math.floor(seconds / 60)
			const secs = Math.floor(seconds % 60)
			return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
		}
	}
}
</script>

<style scoped>
.player-page {
	height: 100vh;
	background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
	padding: 40rpx 30rpx;
	display: flex;
	flex-direction: column;
	color: white;
	overflow: hidden;
	box-sizing: border-box;
}

/* 顶部栏 */
.top-bar {
	display: flex;
	align-items: center;
	justify-content: space-between;
	margin-bottom: 60rpx;
}

.back-icon, .share-icon {
	font-size: 40rpx;
	padding: 10rpx;
}

.song-title {
	flex: 1;
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 5rpx;
}

.title {
	font-size: 32rpx;
	font-weight: bold;
}

.subtitle {
	font-size: 24rpx;
	opacity: 0.8;
}

/* 电台区域 */
.radio-section {
	flex: 1;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	padding: 60rpx 0;
	min-height: 0;
}

.radio-container {
	position: relative;
	width: 400rpx;
	height: 400rpx;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-bottom: 60rpx;
}

.radio-icon-large {
	font-size: 200rpx;
	z-index: 2;
	animation: float 3s ease-in-out infinite;
}

@keyframes float {
	0%, 100% {
		transform: translateY(0);
	}
	50% {
		transform: translateY(-20rpx);
	}
}

.radio-waves {
	position: absolute;
	width: 100%;
	height: 100%;
	display: flex;
	align-items: center;
	justify-content: center;
}

.wave {
	position: absolute;
	width: 100%;
	height: 100%;
	border-radius: 50%;
	border: 3rpx solid rgba(255, 255, 255, 0.3);
	opacity: 0;
}

.radio-waves.active .wave {
	animation: wave-pulse 2s ease-out infinite;
}

.radio-waves.active .wave:nth-child(1) {
	animation-delay: 0s;
}

.radio-waves.active .wave:nth-child(2) {
	animation-delay: 0.6s;
}

.radio-waves.active .wave:nth-child(3) {
	animation-delay: 1.2s;
}

@keyframes wave-pulse {
	0% {
		transform: scale(0.8);
		opacity: 0.8;
	}
	100% {
		transform: scale(1.5);
		opacity: 0;
	}
}

.radio-info {
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 20rpx;
}

.radio-status {
	font-size: 32rpx;
	font-weight: bold;
	color: white;
}

.radio-meta {
	font-size: 26rpx;
	color: rgba(255, 255, 255, 0.7);
}

/* 封面区域 */
.cover-section {
	flex: 1;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 60rpx 0;
	cursor: pointer;
	min-height: 0;
}

.cover-container {
	width: 550rpx;
	height: 550rpx;
	position: relative;
}

.cover-container.rotating .cover-image {
	animation: rotate 20s linear infinite;
}

@keyframes rotate {
	from { transform: rotate(0deg); }
	to { transform: rotate(360deg); }
}

.cover-image {
	width: 100%;
	height: 100%;
	border-radius: 50%;
	box-shadow: 0 20rpx 60rpx rgba(0, 0, 0, 0.3);
}

.cover-disc {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	width: 180rpx;
	height: 180rpx;
	border-radius: 50%;
	background: rgba(0, 0, 0, 0.5);
	backdrop-filter: blur(10rpx);
}

/* 歌词区域 */
.lyrics-section {
	flex: 1;
	display: flex;
	flex-direction: column;
	background: rgba(0, 0, 0, 0.3);
	backdrop-filter: blur(20rpx);
	border-radius: 30rpx;
	margin: 60rpx 0 30rpx 0;
	overflow: hidden;
	cursor: pointer;
	min-height: 0;
}

.lyrics-scroll {
	flex: 1;
	min-height: 0;
	padding: 40rpx 0;
	box-sizing: border-box;
}

.lyrics-list {
	padding: 0 40rpx;
}

.lyrics-padding {
	height: 50vh;
}

.lyric-line {
	text-align: center;
	padding: 20rpx 0;
	font-size: 28rpx;
	color: rgba(255, 255, 255, 0.5);
	line-height: 1.6;
	transition: all 0.3s;
}

.lyric-line.active {
	font-size: 36rpx;
	color: white;
	font-weight: bold;
	transform: scale(1.1);
}

.lyrics-end {
	text-align: center;
	padding: 40rpx 0;
	font-size: 24rpx;
	color: rgba(255, 255, 255, 0.3);
}

/* 操作栏 */
.action-bar {
	display: flex;
	justify-content: space-around;
	padding: 40rpx 0;
}

.action-icon {
	font-size: 48rpx;
	padding: 10rpx;
	opacity: 0.8;
	transition: all 0.3s;
}

.action-icon.active {
	opacity: 1;
	transform: scale(1.2);
}

/* 进度条 */
.progress-section {
	display: flex;
	align-items: center;
	gap: 20rpx;
	margin-bottom: 40rpx;
}

.time-text {
	font-size: 22rpx;
	width: 80rpx;
	text-align: center;
	opacity: 0.8;
}

.progress-slider {
	flex: 1;
}

/* 控制栏 */
.control-section {
	display: flex;
	justify-content: space-around;
	align-items: center;
	padding: 20rpx 0;
}

.control-section.radio-controls {
	justify-content: center;
	gap: 80rpx;
}

.control-btn {
	width: 90rpx;
	height: 90rpx;
	display: flex;
	align-items: center;
	justify-content: center;
	border-radius: 50%;
	background: rgba(255, 255, 255, 0.2);
	backdrop-filter: blur(10rpx);
	transition: all 0.3s;
}

.control-btn:active {
	transform: scale(0.95);
	background: rgba(255, 255, 255, 0.3);
}

.play-btn {
	width: 120rpx;
	height: 120rpx;
	background: rgba(255, 255, 255, 0.9);
}

.control-icon {
	font-size: 36rpx;
	color: white;
}

.control-icon.large {
	font-size: 44rpx;
}

.control-icon.extra-large {
	font-size: 56rpx;
	color: #667eea;
}

.play-btn .control-icon {
	color: #667eea;
}
</style>

